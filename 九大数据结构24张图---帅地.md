九大数据结构24张图---帅地

![image-20200604224724477](E:\Program\Images\9数据结构24图\image-20200604224724477.png)

1 数组

![image-20200604225126128](E:\Program\Images\9数据结构24图\image-20200604225126128.png)

​    数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。



2 链表

![image-20200604225257545](E:\Program\Images\9数据结构24图\image-20200604225257545.png)

​    链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。

这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。

一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。

![image-20200604225319430](E:\Program\Images\9数据结构24图\image-20200604225319430.png)

3 跳表

链表通过增加指针域提升了自由度，但却导致数据的查询效率恶化。特别当链表长度很长时，对数据的查询还需要从头开始，这样效率低。跳表就解决了这样的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提示至O(logn)。

![image-20200604225730426](E:\Program\Images\9数据结构24图\image-20200604225730426.png)

跳表通过增加的多级索引实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。

从上图看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查血的目的。

4 栈

​    只在一端后进先出的线性表（有限的线性序列）。栈的常用操作包括入栈push和出栈pop。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其他数据结构相结合可获得许多灵活的处理。

5 队列

   队列是栈的兄弟结构，与栈的后进先出相对应，队列是先进先出的数据结构。常与栈一同配合，可发挥最大的实力。

6 树

   树的数据存储在结点中，没个结点有零个或者多个子结点，子结点之间没有交集。也即一个结点可以有多个孩子，但一个孩子只能有一个双亲结点。只有两个结点的树称为二叉树。

   二叉树根据结点的排列和数量还可以进一步分为完全二叉树、满二叉树、平衡二叉树、红黑树等。

完全二叉树：除了最后一层结点，其它层的结点数都达到最大值；同时最后一层的结点按照从左到右依次排布。

![image-20200605085558103](E:\Program\Images\9数据结构24图\image-20200605085558103.png)

满二叉树：除了最后一层，其它层的结点都有两个子结点。

   6.1**平衡二叉树**（根据发明者的名字命名）——二叉排序搜索树

​       平衡二叉树又称为**AVL**树，是一棵二叉排序树，具有以下性质：他是一棵空树或它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。

​      **二叉排序树**：是一棵空树，或者：若它的左子树不空，则左子树所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树所有结点的值均大于它的根结点的值，它的左右子树也分别为二叉排序树。

​      树的高度：结点层次的最大值

​      **平衡因子**：左子树高度-右子树高度

​      二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点<根结点<右节点，这表明二叉排序树的中序遍历是有序的。

![image-20200605085836758](E:\Program\Images\9数据结构24图\image-20200605085836758.png)

**平衡排序树是为了解决二叉排序树在插入时发生线性排列的情况。**由于二叉树本身有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查找和插入效率恶化。

![image-20200605091424442](E:\Program\Images\9数据结构24图\image-20200605091424442.png)

平衡二叉树能够解决上述问题，但是在构造平衡二叉树时，却要采用不同的旋转方式，使二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。后两种本质上只是LL和RR的组合。

​      <u>插入结点后应该沿搜索路径将所有路径的结点平衡因子进行修改，当大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，若果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转平衡化。</u>

​      左旋：S为当前需要左旋的结点，E为当前结点的父结点。

![image-20200605092358236](E:\Program\Images\9数据结构24图\image-20200605092358236.png)

左旋可以总结为一句话：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父节点内E旋转为当前结点S的左孩子。

![平衡二叉树左旋](E:\Program\Images\9数据结构24图\平衡二叉树左旋.gif)

右旋同理。

   **红黑树**

  平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的时间复杂度都是O（logN）。但由于需要维持这份高度平衡平衡，所付出的代价就是当对树中结点进行插入和删除时，需要多次旋转实现复衡。<u>这导致AVL的插入和删除效率并不高</u>。

   红黑树申请出战！！！

   红黑树的五个特性：

​       **1每个结点要么是红的，要么是黑的。**

​       **2根结点是黑的。**

​       **3每个叶结点（树尾端NIL指针或者NULL结点）都是黑的。**

​       **4如果一个结点是红的，那么它的两个儿子都是黑的。**

​       **5对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。**      

​    红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只求达到部分平衡。这是一种折中方案，大大提高了结点删除和插入的效率。

红黑树VS平衡二叉树

![image-20200605095342814](E:\Program\Images\9数据结构24图\image-20200605095342814.png)

除了上面所提到的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的结构。比如B树，B+树等。

